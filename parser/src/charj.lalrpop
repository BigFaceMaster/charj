use std::str::FromStr;

use crate::location::{Loc, Location};
use crate::lexer;
use crate::token::{Token, CommentType};
use crate::error::LexicalError;
use crate::parse_tree::*;

grammar<'input>(input: &'input str, file_no: usize);

pub Charj: SourceUnit = {
    SourceUnitPart+ => SourceUnit(<>)
};

SourceUnitPart: SourceUnitPart = {
    PackageDirective => SourceUnitPart::PackageDirective(<>),
    ImportDirective => SourceUnitPart::ImportDirective(<>),
    StructDefinition => SourceUnitPart::StructDefinition(<>),
    FunctionDefinition => SourceUnitPart::FunctionDefinition(<>),
    StructFunctionDefinition => SourceUnitPart::StructFunctionDefinition(<>),
}

PackageDirective: Package = {
   "package" <s:Identifier> => Package::Plain(s),
   "pkg" <s:Identifier> => Package::Plain(s),
}

ImportDirective: Import = {
    "import" <s:Identifier> => Import::Standard(s),
    "import" <s:StringLiteral> "as" <id:Identifier> ";" => Import::GlobalSymbol(s, id)
}

StructDefinition: Box<StructDefinition> = {
     <l:@L> "struct" <name:Identifier> "{" <fields:(<VariableDeclaration> ";")*> "}" <r:@R> => {
        Box::new(StructDefinition{loc: Loc(l, r), name, fields})
    }
}

FunctionDefinition: Box<FunctionDefinition> = {
    <l:@L> "fun" <name:Identifier> <params:ParameterList?> "{" <body:Suite> "}" <r:@R> => {
        let params = params.unwrap_or(Vec::new());
        Box::new(FunctionDefinition {
            loc: Loc(l, r),
            name,
            params,
            body,
       })
    }
};

StructFunctionDefinition: Box<StructFunctionDefinition> = {
    <l:@L> <struct_name:Identifier> "$" <name:Identifier> <params:ParameterList?> "{" <body:Suite> "}" <r:@R> => {
        let params = params.unwrap_or(Vec::new());
        Box::new(StructFunctionDefinition{
            loc: Loc(l, r),
            name, struct_name,
            params,
            body
        })
    }
}

VariableDeclaration: VariableDeclaration = {

};

Suite: Suite = {
    <s:Statement+> => s.into_iter().flatten().collect(),
};

Statement: Suite = {
    SimpleStatement,
    <s:CompoundStatement> => vec![s],
};

CompoundStatement: Statement = {
    IfStatement,
    WhileStatement,
    ForStatement,
}

SimpleStatement: Suite = {
    <s1:SmallStatement> <s2:(";" SmallStatement)*> ";"? "\n" => {
        let mut statements = vec![s1];
        statements.extend(s2.into_iter().map(|e| e.1));
        statements
    }
}

SmallStatement: Statement = {
    FlowStatement,
}

FlowStatement: Statement = {
    <l:@L> "break" <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::Break,
        }
    },
    <l:@L> "continue" <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::Continue,
        }
    },
    <l:@L> "return" <value:ReturnList?> <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::Return { value },
        }
    },
}

ReturnList: Expression = {
    <l:@L> <elements:OneOrMore<ReturnValue>> <trailing_comma: ","?> <r:@R> => {
        Expression {
            location: Location::new(l, r),
            node: ExpressionType::List { elements },
        }
    }
}

ReturnValue: Expression = {
    <l:@L><n:Identifier><r:@R> => {
        Expression {
            location: Location::new(l, r),
            node: ExpressionType::Identifier { name: n }
        }
    }
}

IfStatement: Statement = {
    <l:@L> "if" "(" ")" "{" "}" <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::If
        }
    }
};

WhileStatement: Statement = {
    <l:@L> "while" "(" ")" "{" "}" <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::While
        }
    }
};

ForStatement: Statement = {
    <l:@L> "for" "(" ")" "{" "}" <r:@R> => {
        Statement {
            location: Location::new(l, r),
            node: StatementType::For
        }
    }
};

// A parameter list is used for function arguments, returns, and destructuring statements.
// In destructuring statements, parameters can be optional. So, we make parameters optional
// and as an added bonus we can generate error messages about missing parameters/returns
// to functions
Parameter: Parameter = {
    <l:@L> <ty:Expression> <name:Identifier?> <r:@R> => {
        let loc = Loc(l, r);
        Parameter{loc, ty, name}
    }
}

Expression: Expression = {
    <l:@L> <name: Identifier> <r:@R> => {
        Expression {
            location: Location::new(l, r),
            node: ExpressionType::Identifier { name }
        }
    }
}

OptParameter: (Loc, Option<Parameter>) = {
    <l:@L> <p:Parameter?> <r:@R> => (Loc(l, r), p),
}

ParameterList: Vec<(Loc, Option<Parameter>)> = {
    "(" ")" => Vec::new(),
    "(" <l:@L> <p:Parameter> <r:@R> ")" => vec!((Loc(l, r), Some(p))),
    "(" <CommaTwo<OptParameter>> ")" => <>,
}

Identifier: Identifier = {
    <l:@L> <n:LexIdentifier> <r:@R> => Identifier{loc: Loc(l, r), name: n.to_string()}
}

StringLiteral: StringLiteral = {
    <l:@L> <s:LexStringLiteral> <r:@R> => {
        StringLiteral{ loc: Loc(l, r), string: s.to_string() }
    }
}

CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+>  => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

#[inline]
OneOrMore<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};


extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        LexIdentifier => Token::Identifier(<&'input str>),
        LexStringLiteral => Token::StringLiteral(<&'input str>),

        DocComment => Token::DocComment(<CommentType>, <&'input str>),
        // operators symbol

        // keywords
        "default" => Token::Default,
        "import" => Token::Import,
        "package" => Token::Package,
        "struct" => Token::Struct,
        "pkg" => Token::Package,
        "as" => Token::As,
        "fun" => Token::Fun,

        // statement
        "if" => Token::If,
        "while" => Token::While,
        "for" => Token::For,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "return" => Token::Return,

        // other symbols
        "\n" => Token::NewLine,
        "$" => Token::Binding,

        ";" => Token::Semicolon,
        "{" => Token::OpenCurlyBrace,
        "}" => Token::CloseCurlyBrace,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "=" => Token::Assign,
        "==" => Token::Equal,
        "=>" => Token::Arrow,
//        "|=" => Token::BitwiseOrAssign,
//        "^=" => Token::BitwiseXorAssign,
//        "&=" => Token::BitwiseAndAssign,
//        "<<=" => Token::ShiftLeftAssign,
//        ">>=" => Token::ShiftRightAssign,
//        "+=" => Token::AddAssign,
//        "-=" => Token::SubtractAssign,
//        "*=" => Token::MulAssign,
//        "/=" => Token::DivideAssign,
//        "%=" => Token::ModuloAssign,
        "?" => Token::Question,
        ":" => Token::Colon,
        "||" => Token::Or,
        "&&" => Token::And,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::More,
        ">=" => Token::MoreEqual,
        "|" => Token::BitwiseOr,
        "&" => Token::BitwiseAnd,
        "^" => Token::BitwiseXor,
        "<<" => Token::ShiftLeft,
        ">>" => Token::ShiftRight,
        "+" => Token::Add,
        "-" => Token::Subtract,
        "*" => Token::Mul,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "**" => Token::Power,
        "!" => Token::Not,
        "~" => Token::Complement,
        "++" => Token::Increment,
        "--" => Token::Decrement,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "." => Token::Member,
        "," => Token::Comma,
    }
}

